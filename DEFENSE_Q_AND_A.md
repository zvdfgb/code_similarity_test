# C语言代码相似度检测系统 - 答辩问题与满分回答指南

## 第一部分：整体架构与设计理念 (Design & Architecture)

### Q1: 请用一分钟介绍一下你的项目。
**回答:**
我的项目是一个**基于 C 语言的代码相似度检测系统**。
它旨在通过量化分析，判断两个 C 语言源文件的结构相似性。
**核心架构**采用了经典的流水线设计，分为三个独立模块：
1.  **预处理 (Preprocessing)**：负责清洗代码，去除注释、宏定义和干扰字符。
2.  **向量化 (Vectorization)**：这是核心算法。我构建了一个 **35维的特征向量模型**，通过统计代码中的关键字（如 `if`, `while`）和运算符的频率，将代码转化为数学向量。
3.  **计算 (Calculation)**：利用 **余弦相似度 (Cosine Similarity)** 算法计算两个向量在多维空间中的夹角，最终输出一个 0-1 的相似度得分。

### Q2: 为什么要采用多文件（模块化）的结构，而不是写在一个 `.c` 文件里？
**回答:**
这是为了遵循**高内聚、低耦合**的软件工程原则。
*   **模块化**: 我将功能拆解为 `preprocess`（清洗）、`vectorization`（特征）、`calculate`（数学）三个模块。
*   **可维护性**: 如果我想优化预处理逻辑，我只需要动 `preprocess.c`，完全不会影响计算模块。
*   **接口分离**: `.h` 文件定义了公开的 API，而 `.c` 文件隐藏了具体实现（比如 `static` 辅助函数），这让代码结构更清晰，也方便多人协作或复用。

### Q3: 你的系统是如何解决“变量名不同但逻辑相同”这种抄袭手段的？
**回答:**
这是我项目中的一个关键设计点。
在早期的版本中，我统计了变量名的数量。但我发现，简单的变量改名（比如把 `int a` 改成 `int count`）或者完全不同的程序（都有很多变量）都会干扰结果。
**解决方案**: 在最终的 `vectorization.c` 模块中，我引入了一个**过滤机制**。虽然分词器会识别出标识符（变量名），但在生成向量时，我**刻意忽略**了用户自定义的标识符、数字常量和字符串内容。
系统**只统计关键字（如 `for`）和运算符（如 `+`）**。这意味着，只要代码的**控制流结构**和**运算逻辑**没变，无论变量名怎么改，生成的特征向量都是几乎一样的，从而精准识别此类抄袭。

---

## 第二部分：代码实现细节 (Implementation Details)

### Q4: 详细讲讲预处理模块（Preprocessing）是用什么方法去除注释的？
**回答:**
预处理模块通过一个**有限状态机 (Finite State Machine)** 的逻辑来实现。
我在遍历文件字符流时，维护了一组状态标志，比如 `in_multiline_comment`（在多行注释中）和 `in_string_literal`（在字符串中）。
*   当检测到 `/*` 时，进入“多行注释状态”，忽略后续字符，直到遇到 `*/` 退出状态。
*   同理，检测到 `"` 进入字符串状态，忽略内容直到遇到闭合的 `"`。
这种方法比简单的正则替换更健壮，能正确处理像 `printf("/* 不是注释 */")` 这样的边缘情况。

### Q5: 这里的 `static` 关键字（在 `preprocess.c` 的 `read_file_content` 函数前）有什么作用？
**回答:**
在这里，`static` 关键字用于限制函数的**作用域 (Scope)**。
它将 `read_file_content` 函数变为**文件私有 (File-scope)**。这意味着这个函数只能在 `preprocess.c` 内部被调用，对于外部文件（如 `main.c`）是**不可见**的。
这是一种**封装 (Encapsulation)** 手段，不仅隐藏了内部实现细节，还避免了不同文件中可能出现的同名函数冲突（命名污染）。

### Q6: 关于内存管理，你是怎么处理文件读取的？如果文件很大怎么办？
**回答:**
我使用了**动态内存分配 (Dynamic Memory Allocation)**。
1.  **获取大小**: 先用 `fseek(file, 0, SEEK_END)` 和 `ftell` 获取文件的字节大小。
2.  **申请内存**: 根据文件大小，使用 `malloc` 在堆区（Heap）申请精确的内存空间。
3.  **防止泄漏**: 在 `main.c` 中，我采用了 `goto cleanup` 模式。无论程序是正常执行完毕，还是中间某一步出错，都会跳转到统一的清理代码块，调用 `free` 释放内存。
这种方式既能处理小文件，也能适应大文件，且最大限度地避免了内存泄漏。

### Q7: 为什么在 `vectorization.c` 里，`i` 和 `j` 的类型从 `int` 改成了 `size_t`？
**回答:**
这是为了**类型安全**和消除编译器警告。
在 C 语言中，`strlen` 返回的是 `size_t`（无符号长整型），它能表示的大小远超 `int`（通常是有符号 32 位）。
如果用 `int` 类型的 `i` 去和 `size_t` 类型的长度做比较（`i < length`），在处理超大文件时可能会溢出变成负数，导致死循环或越界。
使用 `size_t` 不仅消除了 `signed/unsigned comparison` 警告，也保证了代码在 64 位系统上处理大文件的正确性。

---

## 第三部分：算法与数学原理 (Algorithm & Math)

### Q8: 为什么要用余弦相似度？欧几里得距离（两点间距离）不行吗？
**回答:**
在文本或代码相似度检测中，余弦相似度优于欧几里得距离。
**原因**:
*   **欧几里得距离**受“长度”影响很大。如果代码 A 是代码 B 的复制粘贴版（长度翻倍），它们的欧氏距离会很大（认为不相似）。
*   **余弦相似度**衡量的是**向量的方向**。只要两个代码中各特征的**比例**一致（比如 `if` 和 `for` 的比例相同），它们的夹角就是 0，余弦值就是 1（完全相似）。
这更符合我们对“代码风格和结构”相似性的定义。

### Q9: 你的特征向量是 35 维的，这 35 维具体是怎么定下来的？
**回答:**
这 35 维是基于 C 语言的语法特性精心挑选的“指纹特征”，定义在 `vectorization.h` 的 `FEATURE_MAP` 中。
它包含：
*   **15 个关键字**: 如 `int`, `return`, `if`, `while` 等，代表控制流和数据类型。
*   **17 个运算符**: 如 `+`, `==`, `&&`, `;` 等，代表运算逻辑。
*   **3 个抽象类**: 原本包含`<变量名>`, `<数字>`, `<字符串>`，但在最终优化中，为了降低误判，我选择在计数时忽略了这三类，让模型专注于前 32 个逻辑特征。

---

## 第四部分：构建与测试 (Build & Test)

### Q10: 那个 `compile.sh` 脚本有什么用？直接 `gcc` 不行吗？
**回答:**
直接用 `gcc`当然可以，但命令会非常长且容易出错。
`compile.sh` 是一个**自动化构建脚本**，它的作用是：
1.  **封装复杂性**: 它集成了所有源文件路径、头文件搜索路径 (`-Iinclude`)、标准指定 (`-std=c11`) 和数学库链接 (`-lm`)。
2.  **工程化**: 它提供了一键编译和一键清理 (`clean`) 功能。
这体现了自动化运维的思想，确保任何人在任何环境下运行脚本，都能得到一致的编译结果。

### Q11: 你是如何验证你的程序是正确的？
**回答:**
我设计了三组对照测试用例（在 `test/` 目录下）：
1.  **Test 1 & 2 (注释不同)**: 验证预处理模块是否有效去除了注释干扰。（预期：100% 相似）
2.  **Test 3 & 4 (顺序不同)**: 验证向量化算法是否不受代码书写顺序的影响。（预期：100% 相似）
3.  **Test 5 & 6 (逻辑不同)**: 验证算法是否能区分冒泡排序和斐波那契数列，这是最关键的测试。在优化（忽略变量名）后，这两者的相似度显著降低，证明了系统能有效识别逻辑差异。

---

## 💡 答辩现场 Tips

1.  **遇到不懂的问题**: 诚实回答。“这个问题我目前还没有深入研究，但我认为它可能与...有关，回去后我会查阅相关资料。”（**不要强行编造**）
2.  **核心亮点**: 抓住机会强调你的**优化点**（忽略变量名统计）和**模块化设计**，这是体现你思考深度的地方。
3.  **自信表达**: 你的代码已经跑通了，测试结果也符合预期，你对每一个字节都了如指掌。加油！
