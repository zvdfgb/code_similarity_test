# C语言代码相似度检测系统项目报告

## 1. 项目概述

**项目名称**: C语言代码相似度检测系统 (Code Similarity Checker)

**项目目标**: 本项目旨在开发一个命令行工具，用于检测两个C语言源代码文件之间的相似度。系统通过预处理、分词、特征向量化和余弦相似度计算，量化代码的结构相似性，从而辅助判断是否存在代码抄袭或复用。

**核心思想**:
系统采用**基于特征向量**的方法。它不直接比较文本内容，而是提取代码的“骨架”特征（如关键字、运算符），忽略变量名、数字常量和字符串内容等“皮肉”细节。通过计算两个代码文件的特征向量在多维空间中的余弦夹角，得出相似度得分。

---

## 2. 项目文件结构

```
D:\coding\C\code_similarity_test\
├── src/                  // 源代码目录
│   ├── main.c            // 主程序入口，负责流程控制
│   ├── preprocess.c      // 预处理模块实现
│   ├── tokenization.c    // 分词模块实现
│   ├── vectorization.c   // 向量化模块实现（核心算法）
│   └── calculate.c       // 计算模块实现（余弦相似度）
├── include/              // 头文件目录
│   ├── preprocess.h      // 预处理模块接口
│   ├── tokenization.h    // 分词模块接口及 Token 结构定义
│   ├── vectorization.h   // 向量化模块接口及特征表定义
│   └── calculate.h       // 计算模块接口
├── test/                 // 测试文件目录
│   ├── test1.c, test2.c  // 场景：代码相同，仅注释不同
│   ├── test3.c, test4.c  // 场景：逻辑相同，代码顺序不同
│   └── test5.c, test6.c  // 场景：逻辑完全不同
├── compile.sh            // 自动化编译脚本
└── PROJECT_REPORT.md     // 本报告文件
```

---

## 3. 核心模块详解

### 3.1 预处理模块 (`src/preprocess.c`)

*   **功能**: 将原始源代码“清洗”为纯净的代码流，消除对结构分析无用的干扰项。
*   **实现细节**:
    *   **移除注释**: 自动识别并删除所有单行注释 (`//...`) 和多行注释 (`/*...*/`)。
    *   **移除干扰元素**: 删除预处理指令 (`#include`, `#define` 等)、字符串字面量 (`"..."`) 和字符字面量 (`'...'`)。
    *   **归一化**: 将所有代码转换为小写，并将连续的空白字符（换行、制表符）压缩为单个空格。
*   **目的**: 确保相似度计算不受代码风格、注释多少或变量命名大小写的影响。

### 3.2 分词模块 (`src/tokenization.c`)

*   **功能**: 将预处理后的字符串分解为一个个独立的单词（Token）。
*   **实现细节**:
    *   定义了 `Token` 结构体和 `TokenType` 枚举（关键字、标识符、数字、字符串、运算符）。
    *   通过状态机逻辑扫描字符流，识别出每一个独立的词法单元。
    *   内置 `is_keyword` 函数，用于区分用户自定义的变量名和C语言保留关键字。

### 3.3 向量化模块 (`src/vectorization.c`) —— **核心逻辑**

*   **功能**: 将分词流转换为数学上的特征向量。
*   **特征定义**: 系统定义了一个 35 维的特征向量，对应 35 种代码特征：
    *   **关键字 (0-14)**: `int`, `if`, `while`, `return` 等。
    *   **运算符 (15-31)**: `+`, `==`, `&&`, `;` 等。
    *   **抽象类别 (32-34)**: `<变量名>`, `<数字>`, `<字符串>`。
*   **关键优化 (防误判机制)**:
    在最新的版本中，为了避免逻辑完全不同的代码因变量定义数量相似而被误判为高相似度，**系统刻意忽略了 `<变量名>`, `<数字>`, `<字符串>` 的统计**。
    *   **逻辑**: `get_feature_index` 函数对于标识符、数字和字符串类型的 Token 直接返回 `-1`。
    *   **效果**: 相似度计算完全基于**关键字**和**运算符**的频率。这意味着算法只比较代码的“逻辑骨架”和“控制流结构”，从而大幅提高了检测的准确性。

### 3.4 计算模块 (`src/calculate.c`)

*   **功能**: 计算两个特征向量的余弦相似度。
*   **算法**:
    $$ 	ext{Similarity} = 
cos(	heta) = rac{A 
cdot B}{\|A\| \|B\|} = rac{\sum_{i=1}^{n} A_i B_i}{\sqrt{\sum_{i=1}^{n} A_i^2} \sqrt{\sum_{i=1}^{n} B_i^2}} $$ 
*   **输出**: 返回一个 [0, 1] 之间的浮点数。1.0 表示特征分布完全一致，0.0 表示完全无共同特征。

### 3.5 主程序 (`src/main.c`)

*   **功能**: 串联整个工作流。
*   **流程**:
    1.  接收命令行参数（两个文件路径）。
    2.  调用 `preprocess_file` 清洗两个文件。
    3.  调用 `generate_vector` 生成各自的特征向量。
    4.  调用 `calculate_cosine_similarity` 计算得分。
    5.  根据得分输出评估结论（极高/高/中/低）。

---

## 4. 编译与运行

本项目提供了自动化编译脚本 `compile.sh`。

### 4.1 编译环境要求
*   GCC 编译器 (支持 C11 标准)
*   Windows/Linux/macOS 命令行环境

### 4.2 编译命令
在项目根目录下运行：

```bash
./compile.sh
# 或者在 Windows 命令行中直接运行编译指令（如果脚本无法运行）：
gcc -Wall -Wextra -Iinclude -std=c11 src/main.c src/preprocess.c src/tokenization.c src/vectorization.c src/calculate.c -o code_similarity_checker.exe -lm
```

编译成功后，将生成 `code_similarity_checker.exe` 可执行文件。

### 4.3 运行命令
```bash
# 语法: 程序名 <文件1> <文件2>
.\code_similarity_checker.exe test\test1.c test\test2.c
```

*(注：在 Windows 命令行中，如遇中文乱码，请先执行 `chcp 65001`)*

---

## 5. 测试案例分析

为了验证系统的准确性，我们设计了三组典型的测试用例：

| 测试组 | 文件内容描述 | 预期结果 | 实际表现 | 分析 |
| :--- | :--- | :--- | :--- | :--- |
| **Group 1** | **test1.c vs test2.c**<br>代码逻辑完全相同，仅注释不同（英文注释 vs 中文注释）。 | **极高相似度** | **100% (1.0)** | 符合预期。预处理模块成功移除了所有注释，剩下的代码骨架完全一致。 |
| **Group 2** | **test3.c vs test4.c**<br>代码逻辑相同，但函数定义的顺序互换了。 | **极高相似度** | **100% (1.0)** | 符合预期。向量化算法基于“词袋模型”统计特征频率，不关注代码出现的先后顺序。 |
| **Group 3** | **test5.c vs test6.c**<br>完全不同的算法（冒泡排序 vs 斐波那契数列）。 | **低相似度** | **< 60%** | 符合预期。由于忽略了变量名数量的干扰，算法敏锐地捕捉到了两者在控制流关键字（循环 vs 递归）和运算符上的巨大差异。 |

---

## 6. 总结

本项目成功实现了一个健壮的 C 语言代码相似度检测工具。通过模块化的设计，系统具有良好的可维护性和扩展性。特别是针对“不同逻辑代码因变量过多导致误判”的问题进行了针对性优化（在向量化阶段忽略标识符统计），显著提升了算法在实际应用场景中的判别能力。
